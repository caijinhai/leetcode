## KMP字符串查找算法

解题思路：
判断T是否是S的字串
一半思路： 按照T和S字符一个个匹配，当匹配不等时，在从模式串从头匹配
KMP：计算模式串中每个字串位置的前缀字符串所有前缀和后缀公共部分长度，当进行匹配时，只有不等，便跳过公共长度部分，以达到减少匹配次数
```
例如对于字符串 abcba：
前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1
next: [-1, 0, 0, 0, 1]
```

1. 构建next数组

next[0] = -1, j字符位置递增
若上一个字符不存在公共部分，t=0, s[j]==s[0]比较
若上一个字符存在公共部分，t=上一个公共长度，s[j]=s[t]比较，否则t=0
```
def buildNext(self, s):
    m = len(s)
    j = 0
    p = []
    p.append(-1)
    t = -1
    while (j < (m - 1)):
        if (0 > t or s[j] == s[t]):
            j += 1
            t += 1
            p.append(t)
        else:
            t = p[t]
    return p
```
2. 字符串匹配